---
id: existing-project
title: Integrate Resonate into an existing project
sidebar_label: Existing project
sidebar_position: 3
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

**How to integrate Resonate into an existing project.**

You can integrate Resonate into an existing project by just adding the Resonate SDK as a dependency and initializing it in your Worker or Application Node.
You don't need to run a Resonate Server to get started â€” Resonate will store all promises in local memory, until you are ready to add remote invocations and long term durability to your application.

## Add the SDK to your project

Add the Resonate SDK to your project as a dependency.

<Tabs
    groupId="language"
    defaultValue="python"
    values={[
        { label: "Python", value: "python" },
        { label: "TypeScript", value: "typescript" },
    ]}
>
    <TabItem value="python">

    <Tabs
    groupId="prefferred-package-manager-py"
    defaultValue="uv"
    values={[
        { label: "uv", value: "uv" },
        { label: "pip", value: "pip" },
        { label: "poetry", value: "poetry" },
    ]}>

    <TabItem value="uv">

```shell
uv add resonate-sdk
```

    </TabItem>

    <TabItem value="pip">

```shell
pip install resonate-sdk
```

    </TabItem>

    <TabItem value="poetry">

```shell
poetry add resonate-sdk
```

    </TabItem>

</Tabs>

    </TabItem>

    <TabItem value="typescript">

<Tabs
    groupId="preferred-package-manager-ts"
    defaultValue="bun"
    values={[
        {label: 'Bun', value: 'bun'},
        {label: 'npm', value: 'npm'},
        {label: 'Yarn', value: 'yarn'},
    ]}>

    <TabItem value="bun">

```shell
bun add @resonatehq/sdk
```

    </TabItem>

    <TabItem value="npm">

```shell
npm install @resonatehq/sdk
```

    </TabItem>

    <TabItem value="yarn">

```shell
yarn add @resonatehq/sdk
```

    </TabItem>

</Tabs>

    </TabItem>

</Tabs>

## Initialize Resonate

Then, initialize Resonate in your script, worker, or application.

You can intialize Resonate in local memory, which does not require any additional dependencies (such as a Resonate Server).
This is a great way to get started and test the integration.

When you are ready to add long term durability and remote invocations, you can switch to a remote store and message source (Resonate Server).

<Tabs
    groupId="language"
    defaultValue="python"
    values={[
        { label: "Python", value: "python" },
        { label: "TypeScript", value: "typescript" },
    ]}
>

    <TabItem value="python">

```python
from resonate import Resonate

# Initialize Resonate with a local promise store
# Great for local development.
resonate = Resonate.local()

# Initialize Resonate with a remote promise store
# Great for building production grade distributed applications.
resonate = Resonate.remote()
```

    </TabItem>

    <TabItem value="typescript">

```typescript
import { Resonate } from "@resonatehq/sdk";

// Initialize Resonate with a local promise store
// Great for local development.
const resonate = Resonate.local();

// Initialize Resonate with a remote promise store
// Great for building production grade distributed applications.
const resonate = Resonate.remote();
```

    </TabItem>

</Tabs>

:::tip Optional Remote mode

Make sure you run a Resonate Server prior to initializing Resonate with `.remote()`

```
brew install resonatehq/tap/resonate
resonate serve
```

If you don't have brew, see the [Server installation guide](/operate/run-server) for more installation options.

:::

## Register a function

Next, register a function with Resonate.
Functions registered and invoked with Resonate gain durable qualities and can be awaited on remotely.

<Tabs
    groupId="language"
    defaultValue="python"
    values={[
        { label: "Python", value: "python" },
        { label: "TypeScript", value: "typescript" },
    ]}
>

    <TabItem value="python">

Register a function with Resonate using the `register` decorator or the `register` method.

All functions registered with Resonate or called from a Resonate function must define Context as the first argument.

```python
# Register a function with the decorator
@resonate.register
def foo(ctx: Context, arg: str) -> str:
    # Your function logic here
    return result

# Register a function with the register method
def foo(ctx: Context, arg: str) -> str:
    # Your function logic here
    return result

resonate.register(foo)

# ...

resonate.start()
```

Calling `resonate.start()` explicitly starts Resonate instance threads.
It is not needed in scripts, workers, or application nodes that call `resonate.run()`, but we recommend doing so with all instances of Resonate.

    </TabItem>

    <TabItem value="typescript">

You can register a function with Resonate using the `register` method.
All functions registered with Resonate or called from a Resonate function must define `Context` as the first argument.

```typescript
function foo(ctx: Context, arg: string): string {
  // Your function logic here
  return result;
}

fooR = resonate.register("foo", foo);
```

    </TabItem>

</Tabs>

## Invoke a function

You can invoke a function that is defined locally in the script, worker, or application node, or you can invoke a function that is defined remotely in a different worker or application .
Invoking a function locally does not require the Resonate Server, but invoking one remotely does.

<Tabs
    groupId="language"
    defaultValue="python"
    values={[
        { label: "Python", value: "python" },
        { label: "TypeScript", value: "typescript" },
    ]}
>

    <TabItem value="python">

If the function is in the same Worker or Application Node, you can invoke it directly with the Resonate Client's Run API.

```python
result = foo.run(promise_id, arg=arg)

# or using the Resonate Client
result = resonate.run(promise_id, func="foo", arg=arg)
```

If the function is in a different Worker or Application Node, you can invoke it with the rpc method on the Resonate instance.
To do this, your worker must be connected to a remote store and message source (Resonate Server).

```python
result = resonate
  .options(target="<transport_plugin>://<unique_id>@<group>/<id>")
  .rpc(promise_id, func="foo", arg=arg)
```

    </TabItem>

    <TabItem value="typescript">

If the function is in the same Worker or Application Node, you can invoke it directly with the Resonate Client's Run API.

```typescript
const result = fooR(promiseId, arg);

// or using the Resonate Client
const result = resonate.run("foo", promiseId, arg);
```

If the function is in a different Worker or Application Node, you can invoke it with the rpc method on the Resonate instance.
To do this, your worker must be connected to a remote store and message source (Resonate Server).

```typescript
const result = await resonate.rpc(
  promiseId,
  "foo",
  arg,
  resonate.options({
    target: "process-group-b",
  })
);
```

    </TabItem>

</Tabs>

## Extend the Call Graph

You can extend your Call Graph by invoking other functions from within a function.

<Tabs
    groupId="language"
    defaultValue="python"
    values={[
        { label: "Python", value: "python" },
        { label: "TypeScript", value: "typescript" },
    ]}
>

    <TabItem value="python">

```python
@resonate.register
def foo(ctx: Context, arg: str) -> str:
    # ...
    r1 = yield ctx.run(bar, arg)
    r2 = yield ctx.run(baz, r1)
    return r2
```

    </TabItem>

    <TabItem value="typescript">

```typescript
function* factorial(ctx: Context, arg): Generator<any, string, any> {
  // ...
  r1 = yield* ctx.run(bar, arg);
  r2 = yield* ctx.run(baz, r1);
  return r2;
}
```

    </TabItem>

</Tabs>
