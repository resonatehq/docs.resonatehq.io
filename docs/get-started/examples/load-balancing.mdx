---
id: load-balancing
title: Start with load balanced workers
description: Start a project that demonstrates Resonate load balancing and recovery.
sidebar_label: Load balancing
tags:
  - get-started
  - new-project
  - template
  - load-balancing
---

![project readme banner](/img/load-balancing.png)

Start a new project using a load balancing use case example.

import CloneRepoGrid from "@site/src/components/CloneRepoGrid/CloneRepoGrid";
import CloneRepoCard from "@site/src/components/CloneRepoCard/CloneRepoCard";

<CloneRepoGrid>
  <CloneRepoCard
    sdk="Python SDK"
    description="Load balancing use case project example"
    link="https://github.com/resonatehq-examples/example-load-balancing-py"
  />
  <CloneRepoCard
    sdk="TypeScript SDK"
    description="Load balancing use case project example"
    link="https://github.com/resonatehq-examples/example-load-balancing-ts"
  />
</CloneRepoGrid>

## Problem

A single worker or microservice instance will eventually become overwhelmed if there is too much work sent its way in a short amount of time.

There are generally two ways to solve for this:

1. Increase the compute capability for the single worker / microservice.
2. Increase the number of worker / microservice instances.

There is an upper limit to the first option, and it is a single point of failure if there is only ever one instance running.

Therefore, the second option tends to be the desired approach, because in theory you can scale the number of instances indefinitely. However, this introduces another problem: service discovery and load balancing â€” that is, knowing which worker / application node has the capacity to take more work.

But what happens if a worker/microservice instance crashes after claiming work and beginning to make progress on it?

How does the system detect the failure and know where to recover that work?

These are distributed system engineering issues that developers are commonly forced to solve again and again. Developers are often forced to mix messy service discovery, load balancing, and recovery logic into their application or business logic. This makes for a poor developer experience.

## Solution

Resonate provides built-in service discovery, load balancing, and recovery, all exposed through a simple RPC API and target schema.

## Quick example

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python" >

```python title="worker.py"
from resonate import Resonate

# Initialize worker as part of "worker-group"
resonate = Resonate.remote(
    group="worker-group",
)

@resonate.register
def compute_something(_, id, compute_cost):
    print(f"starting computation {id}")
    time.sleep(compute_cost)  # Simulate work
    print(f"computed something that cost {compute_cost} seconds")
    return

resonate.start()
```

```python title="client.py"
# Invoke any worker in the group
resonate.run(
    id,
    compute_something,
    id,
    compute_cost,
    opts=resonate.options(
        target="poll://any@worker-group"  # Load balance across workers
    )
)
```

  </TabItem>

    <TabItem value="typescript" >

```typescript title="worker.ts"
import { Resonate } from "@resonatehq/sdk";
import type { Context } from "@resonatehq/sdk";

// Initialize worker as part of "workers" group
const resonate = Resonate.remote({
  group: "workers",
});

function computeSomething(context: Context, args: any): void {
  console.log(`${args.id} starting computation`);
  setTimeout(() => {
    console.log(`${args.id} computed something that cost ${args.computeCost} seconds`);
  }, args.computeCost * 1000);
  return;
}

resonate.register("computeSomething", computeSomething);
```

```typescript title="client.ts"
// Invoke any worker in the group
resonate.rpc(
  id,
  "computeSomething",
  { id, computeCost },
  resonate.options({
    target: "poll://any@workers",  // Load balance across workers
  })
);
```

  </TabItem>

</Tabs>
