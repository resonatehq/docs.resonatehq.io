---
id: quickstart
title: Quickstart
sidebar_label: Quickstart
sidebar_position: 1
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Install the Resonate Server & CLI

```shell
brew install resonatehq/tap/resonate
```

## Install the Resonate SDK

<Tabs groupId="language" defaultValue="typescript" values={[
  { label: "TypeScript", value: "typescript" },
  { label: "Python", value: "python" },
]}>

<TabItem value="typescript">

```shell
npm install @resonatehq/sdk
```

</TabItem>

<TabItem value="python">

```shell
pip install resonate-sdk
```

</TabItem>

</Tabs>

## Write your first Resonate Function

A countdown as a loop. Simple, but the function can run for minutes, hours, or days, despite restarts.

<Tabs groupId="language" defaultValue="typescript" values={[
  { label: "TypeScript", value: "typescript" },
  { label: "Python", value: "python" },
]}>

<TabItem value="typescript">

```typescript title="countdown.ts"
import { Resonate, type Context } from "@resonatehq/sdk";

function* countdown(context: Context, count: number, delay: number) {
  for (let i = count; i > 0; i--) {
    // Run a function, persist its result
    yield* context.run((context: Context) => console.log(`Countdown: ${i}`));
    // Sleep
    yield* context.sleep(delay * 1000);
  }
  console.log("Done!");
}
// Instantiate Resonate
const resonate = new Resonate({ url: "http://localhost:8001" });
// Register the function
resonate.register(countdown);
```

</TabItem>

<TabItem value="python">

```python title="countdown.py"
from resonate import Resonate
from resonate.context import Context

def countdown(ctx: Context, count: int, delay: int):
    for i in range(count, 0, -1):
        # Run a function, persist its result
        yield ctx.run(lambda c, i=i: print(f"Countdown: {i}"))
        # Sleep
        yield ctx.sleep(delay * 1000)
    print("Done!")

# Instantiate Resonate
resonate = Resonate(url="http://localhost:8001")
# Register the function
resonate.register(countdown)
```

</TabItem>

</Tabs>

## Start the server

```shell
resonate dev
```

## Start the worker

<Tabs groupId="language" defaultValue="typescript" values={[
  { label: "TypeScript", value: "typescript" },
  { label: "Python", value: "python" },
]}>

<TabItem value="typescript">

```shell
npx ts-node countdown.ts
```

</TabItem>

<TabItem value="python">

```shell
python countdown.py
```

</TabItem>

</Tabs>

## Run the function

Run the function with execution ID `countdown.1`:

```shell
resonate invoke countdown.1 --func countdown --arg 5 --arg 60
```

## Result

You will see the countdown in the terminal

<Tabs groupId="language" defaultValue="typescript" values={[
  { label: "TypeScript", value: "typescript" },
  { label: "Python", value: "python" },
]}>

<TabItem value="typescript">

```shell
npx ts-node countdown.ts
Countdown: 5
Countdown: 4
Countdown: 3
Countdown: 2
Countdown: 1
Done!
```

</TabItem>

<TabItem value="python">

```shell
python countdown.py
Countdown: 5
Countdown: 4
Countdown: 3
Countdown: 2
Countdown: 1
Done!
```

</TabItem>

</Tabs>

## What to try

After starting the function, inspect the current state of the execution using the `resonate tree` command. The tree command visualizes the call graph of the function execution as a graph of durable promises.

```shell
resonate tree countdown.1
```

Now try killing the worker mid-countdown and restarting. **The countdown picks up right where it left off without missing a beat.**

## Next steps

- [Learn how Resonate works](/evaluate/how-it-works)
- [Explore project templates](/get-started/project-templates)
- [Build a real application](/learn)
