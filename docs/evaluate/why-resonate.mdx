---
id: why-resonate
title: Why Resonate
sidebar_label: Why Resonate
sidebar_position: 1
description: There are a lot of reasons why you should consider adopting Resonate.
last_update:
  date: "03-12-2025"
tags:
  - evaluate
---

**What problem does Resonate solve?**

## Complexity is pain

Resonate is fundamentally about reducing complexity for developers building reliable and scalable software systems.

Developers still experience a great deal of pain from all the complexity that's crammed in at the application level â€”
Complexity, which is added, to solve for reliability and scalability.

Practically, this means that failure retry, crash recovery, idempotency, service discovery, load balancing, asynchronous messages, etc, are things that developers have to repeatedly think about and solve for alongside their use case.

More or less, the complexity and the pain, stem from a system's desire to be concurrent and distributed.
_Why?_ So the system is scalable and reliable!
Concurrency and distribution enable scalability and reliability.
However, the more concurrency and distribution there is, the more complex the code becomes.
When the code becomes distributed and complex - the system becomes hard to build, hard to maintain, and hard to reason about.
These challenges can erode the confidence, speed, and joy of development.

Resonate addresses this pain holistically.
Resonate pushes all that complexity (failure retry, crash recovery, idempotency guarantees, service discovery, load balancing, asynchronous messages, etc.) into the platform and provides developers with a simple set of APIs to use at the application level.

_Using Resonate makes reliable and scalable applications dead simple to develop, dead simple to deploy, and dead simple to operate._

**When to use Resonate?**

## Systems engineering for ...

_Use Resonate as soon as you realize you need or have a software system!_

The [Distributed Async Await spec](https://distributed-async-await.io), and its underlying [Async RPC protocol](https://asynchronous-rpc.io), was intended to be a general-purpose programming and execution model for building reliable and scalable software systems.
As an implementation of that spec, Resonate has successfully inherited that intended trait.
For example...

- **Autonomous systems & agentic applications**: Dominik Tornow breaks it all down in his online book [Systems Engineering for Agentic Applications](https://systems-engineering-for-agentic-applications.resonatehq.io/)
- **Function-as-a-Service**: Whether you are building a Function-as-a-Service (FaaS) platform, see [Building a Demo FaaS Platform with Resonate](https://journal.resonatehq.io/p/building-a-demo-faas-platform-with) or using one, see [GCP countdown workflow example application](https://github.com/resonatehq-examples/example-countdown-ts-gcp), Resonate's execution model makes it ideal for both.
- **Financial systems**:Resonate is well-suited for building distributed financial systems that require strong consistency and reliability, explored in depth in the article [Maintaining Consistency in the absence of transactions](https://maintaining-consistency-in-distributed-financial-systems.resonatehq.io/).

Resonate's programming model serves developers by offering a clean, simple, and reliable pattern for awaiting on things in your event loop, whether that is a function executing, a human verifying some work, or an AI agent taking the step next.
This makes it great for basically anything relying on a system.

## Quality standards

There are at least two things that we do that should paint a picture of our commitment to quality.

_First is formal modeling and formal verification._

Resonate is an implementation of the [Distributed Async Await specification](https://distributed-async-await.io), which relies on the [Asynchronous RPC protocol](https://asynchronous-rpc.io).
These underlying specs have been and continue to undergo formal modeling exercises, which probe their correctness.

_Second is simulation testing._

Each major component in Resonate, the Resonate Server and each of the SDKs, is subjected to Deterministic Simulation Testing (DST).
This is of course on top of traditional unit testing and integration testing.
DST identifies complex edge cases that may cause unexpected behavior in production, well before the code is ever released.

These two things set a foundation of quality that we build upon with every release.

## Open everything

The underlying Async RPC protocol, the Distributed Async Await specification, and Resonate are all fully open source.

Adopting Resonate does mean that you are adopting Distributed Async Await.
But it doesn't mean you are locked into Resonate specifically.

Everything you need to fork or build your own is available to you.

But, the deeper philosophy is in imagining a world where every service, API, and distributed component used Durable Promises and Async RPC.
Different implementations of the Distributed Async Await spec could interoperate seamlessly.
And developers stay in control with far less complexity.
