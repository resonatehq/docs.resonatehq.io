---
id: why-resonate
title: Why Resonate
sidebar_label: Why Resonate
sidebar_position: 1
description: There are a lot of reasons why you should consider adopting Resonate.
last_update:
  date: "03-12-2025"
tags:
  - evaluate
---

**What problem does Resonate solve?**

## Modern pain points

Let's try to answer the question, "what problem does Resonate solve?", within the context of today's software development landscape.

Take a step back for a moment and consider the time we are living in.

_Will AI replace software developers â€” or will it empower them?_

Resonate was made by developers for developers, knowing that Software Developers, Engineers, and Architects will continue to be the sensible decision makers on how to deliver the intended value of software.
Sensible AI will help developers' not direct them.
With that in mind, it's critical to continue to address developer pain points and improve developer experience.

Because, developers do still experience a lot of pain with distributed applications.
There is too much complexity that's crammed in at the application level.
Practically, failure retry, crash recovery, idempotency, service discovery, load balancing, suspension, etc, are things that developers have to repeatedly think about and solve for.

More or less, the complexity and the pain, stem from a system's desire to be concurrent and distributed.
_Why?_ So the system is scalable and reliable!
Concurrency and distribution enable scalability and reliability.
However, the more concurrency and distribution there is the more complex the code becomes.
When the code becomes distributed and complex - the system becomes hard to build, hard to maintain, and hard to reason about.

Resonate addresses this pain holistically.
Resonate pushes all that complexity (failure retry, crash recovery, idempotency, service discovery, load balancing, suspension, etc.) into the platform and provides developers with a simple set of APIs to use at the application level.

_Using Resonate makes reliable and scalable applications dead simple to develop, dead simple to deploy, and dead simple to operate._

**When to use Resonate?**

## Systems engineering for ...

_Use Resonate as soon as you realize you need or have a software system!_

The [Distributed Async Await spec](https://distributed-async-await.io), and its underlying [Async RPC protocol](https://asynchronous-rpc.io), was intended to be a general-purpose programming and execution model for building reliable and scalable software systems.
As an implementation of that spec, Resonate has successfully inherited that intended trait.
For example...

- **Autonomous systems & agentic applications**: Dominik Tornow breaks it all down in his online book [Systems Engineering for Agentic Applications](https://systems-engineering-for-agentic-applications.resonatehq.io/)
- **Function-as-a-Service**: Whether you are building a Function-as-a-Service (FaaS) platform, see [Building a Demo FaaS Platform with Resonate](https://journal.resonatehq.io/p/building-a-demo-faas-platform-with) or using one, see [GCP countdown workflow example application](https://github.com/resonatehq-examples/example-countdown-ts-gcp), Resonate's execution model makes it ideal for both.
- **Financial systems**:Resonate is well-suited for building distributed financial systems that require strong consistency and reliability, explored in depth in the article [Maintaining Consistency in the absence of transactions](https://maintaining-consistency-in-distributed-financial-systems.resonatehq.io/).

Resonate's programming model serves developers by offering a clean, simple, and reliable pattern for awaiting on things in your event loop, whether that is a function executing, a human verifying some work, or an AI agent taking the step next.
This makes it great for basically anything relying on a system.

## Quality standards

There are at least two things that we do that should paint a picture of our committment to quality.

_First is formal modeling and formal verification._

Resonate is an implementation of the [Distributed Async Await specification](https://distributed-async-await.io), which relies on the [Asynchronous RPC protocol](https://asynchronous-rpc.io).
These underlying specs have been and continue to undergo formal modeling exercises, which probe their correctness.

_Second is simulation testing._

Each major component in Resonate, the Resonate Server and each of the SDKs, is subjected to Deterministic Simulation Testing (DST).
This is of course on top of traditional unit testing and integration testing.
DST identifies complex edge cases that may cause unexpected behavior in production, well before the code is ever released.

These two things set a foundation of quality that we build upon with every release.

## Open everything

The underlying Async RPC protocol, the Distributed Async Await specification, and Resonate are all fully open source.

Adopting Resonate does mean that you are adopting Distributed Async Await.
But it doesn't mean you are locked into Resonate specifically.

Everything you need to fork or build your own is available to you.

But, the deeper philosophy is in imagining a world where every service, API, and distributed component used Durable Promises and Async RPC.
Different implementations of the Distributed Async Await spec could interoperate seamlessly.
And developers stay in control with far less complexity.
