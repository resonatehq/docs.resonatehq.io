---
id: dbos
title: Coming from DBOS
description: Compare Resonate with DBOS to understand key differences and similarities.
sidebar_label: DBOS
sidebar_position: 5
tags:
  - evaluate
  - comparison
---

**Are you coming from DBOS?**

If so, this guide is meant to help you understand the differences and similarities between Resonate and DBOS.

## Durability

A core value proposition of DBOS is its durable workflows.
A durable workflow or Durable Execution is one that can recover in another process after a hard failure and resume from where it left off.

Resonate also provides durable workflows (Durable Executions).

In Resonate, if your process crashes, your function can recover and resume from where it left off in another process.

## Programming model

If you have experience with DBOS, then you are familiar with thinking in terms of Workflows and Steps.

Resonate does not have proprietary function types such as Workflows and Steps – you just write functions.

Resonate promotes a procedural programming model that enables you to compose functions indefinitely and recursively.

Consider this factorial example.
How might you implement it in DBOS?

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>

    <TabItem value="python">

See it in action: [example-recursive-factorial-py](https://github.com/resonatehq-examples/example-recursive-factorial-py)

```python
@resonate.register
def factorial(ctx: Context, n: int) -> int:
    if n <= 1:
        return 1
    r = yield ctx.run(factorial, n - 1).options(id=f"factorial-{n-1}")
    return n * r


def main():
    result = factorial.run("factorial-5", n=5)
    print(result)
```

    </TabItem>

    <TabItem value="typescript">

See it in action: [example-recursive-factorial-ts](https://github.com/resonatehq-examples/example-recursive-factorial-ts)

```typescript
function* factorial(ctx: Context, n: number): Generator<any, number, any> {
  if (n <= 1) {
    return 1;
  }
  const result = yield* ctx.run(factorial, n - 1);

  return n * result;
}

const factorialR = resonate.register("factorial", factorial);

async function main() {
  const result = await factorialR.run("factorial-5", 5);
  console.log(result);
}
```

    </TabItem>

</Tabs>

## Zero-dependency development

With DBOS, your Worker or application must always connect to a Postgres database, whether it’s a local development or a production instance.

Resonate offers a zero-dependency development experience, where a Worker (single node application) can run without connecting to a Resonate Server.

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>

    <TabItem value="python">

```python
from resonate import Resonate

resonate = Resonate.local()

#...

```

    </TabItem>

    <TabItem value="typescript">

```typescript
import { Resonate } from "@resonatehq/sdk";

const resonate = Resonate.local();

// ...
```

    </TabItem>

</Tabs>

## Human-in-the-loop

With DBOS, you can use a '@recv' function to block the Workflow and await input from a human.

With Resonate, you can achieve the same effect by creating a Durable Promise that is not attached to any function execution, and then await on it.
Then, you can resolve it from anywhere, optionally sending data into the function while doing so.

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>

    <TabItem value="python">

See it in action: [example-human-in-the-loop-py](https://github.com/resonatehq-examples/example-human-in-the-loop-py)

```python
# worker.py
@resonate.register()
def foo(ctx: Context) -> None:
    blocking_promise = yield ctx.promise()
    # ...
    # wait for the promise to be resolved
    data = yield blocking_promise
    # ...
```

```python
# client.py
def main():
    # ...
    resonate.promises.resolve(
        id=promise_id,
        data=json.dumps(data)
    )
```

    </TabItem>

    <TabItem value="typescript">

See it in action: [example-human-in-the-loop-ts](https://github.com/resonatehq-examples/example-human-in-the-loop-ts)

```typescript
function* foo(context: Context) {
  const blockingPromise = yield* context.promise();
  // ...
  // wait for the promise to be resolved
  data = yield* blockingPromise;
  // ...
}
```

```typescript
// client.ts
await resonate.promises.resolve({ id: promiseId, data: JSON.stringify(data) });
```

    </TabItem>

</Tabs>

## Distributed execution

A major difference between Resonate and DBOS is that Resonate can orchestrate executions across multiple Workers while DBOS cannot.
With Resonate, you can run multiple Workers in a group, and Resonate will automatically load-balance invocations across them.

Consider the following Resonate example.
How would you accomplish this using DBOS?

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>

    <TabItem value="python">

See it in action: [example-load-balancing-py](https://github.com/resonatehq-examples/example-load-balancing-py)

```python
# worker.py
resonate = Resonate.remote(
    group="workers"
    # ...
)
```

```python
# client.py
resonate = Resonate.remote(
    group="client"
)

def main():
    # ...
    result = resonate.options(target="poll://any@workers").rpc(promise_id, "function_name", params)
```

    </TabItem>

    <TabItem value="typescript">

See it in action: [example-load-balancing-ts](https://github.com/resonatehq-examples/example-load-balancing-ts)

```typescript
// worker.ts
const resonate = Resonate.remote({
  group: "workers",
});
```

```typescript
//client.ts
const resonate = Resonate.remote({
  group: "client",
});

async function main() {
  resonate.rpc(
    promiseId,
    "function_name",
    params,
    resonate.options({
      target: "poll://any@workers",
    })
  );
}
```

    </TabItem>

</Tabs>

DBOS is designed to ensure durability for a single instance of an application.
When a DBOS application process crashes, an operator must restart the application for any in-progress functions/workflows to recover and resume.

Resonate will automatically recover and resume in-progress functions/workflows in another Worker.

In essence, DBOS focuses on single-instance durability without addressing scalability, while Resonate holistically addresses the needs of modern distributed systems.
