---
id: coming-from-temporal
title: Coming from Temporal
sidebar_label: Coming from Temporal
sidebar_position: 3
description: If you are coming from Temporal, this guide will help you understand the differences and similarities between Temporal and Resonate.
last_update:
  date: "07-21-2025"
tags:
  - evaluate
  - comparison
---

**Are you coming from experience with Temporal?**

If so, this page will help you understand the differences and similarities between Resonate and Temporal.

## Building blocks

If you’ve used Temporal before, you know about Workflows and Activities.

In Temporal, a Workflow is the main function that orchestrates the execution of Activities, the steps in the process.
Activities can execute sequentially or concurrently.

In Resonate, there are no explicit Workflows or Activities — you just write functions.
Resonate functions can also run sequentially or concurrently.
But, they can also compose indefinitely and recursively.
However, if it helps, you can think of the top-level function that you register with Resonate as your "Workflow".

Then, similar to Temporal, when you invoke a function in Resonate you get a "Future" or "Promise" that you can await on to get the result when it’s ready.
In Resonate, we call these **Durable Promises**.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
    groupId="language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>

    <TabItem value="python">

Comparison of Python SDKs between Resonate and Temporal.

        <Tabs
        defaultValue="resonate"
        values={[
            {label: 'Resonate', value: 'resonate'},
            {label: 'Temporal', value: 'temporal'},
        ]}
        >

            <TabItem value="resonate">

```python
from resonate import Resonate

resonate = Resonate()

@resonate.register
def foo(ctx, params):
    p1 = yield ctx.lfi(bar, params)
    result = yield p1
    p2 = yield ctx.lfi(baz, result)
    result = yield p2
    return result

def bar(ctx, params):
    return result


def baz(ctx, params):
    return result
```

    </TabItem>

    <TabItem value="temporal">

```python
from temporalio import workflow

@workflow.defn()
class YourWorkflow:

    @workflow.foo
    async def foo(self, params):
        result = await workflow.execute_activity(
            bar,
            params,
            start_to_close_timeout=timedelta(seconds=10),
        )

        result = await workflow.execute_activity(
            baz,
            result,
            start_to_close_timeout=timedelta(seconds=10),
        )
        return result


async def bar(params):
    return result


async def baz(params):
    return result
```

            </TabItem>

        </Tabs>

Although we often say that Resonate "just uses functions", the Resonate Python SDK actually supports both coroutines and regular functions.

Any function that uses `yield` is a coroutine, and any function that does not use `yield` is a regular function.
The coroutines enable Resonate to pause and resume execution which is how Resonate maintains control.

Temporal uses Python's `async/await` syntax, running Workflows and Activities inside a sandbox environment that gives Temporal control over execution.

In a way, you can draw a parallel to Temporal's Workflows and Activities, where Workflows are coroutines and Activities are regular functions.

However, Resonate enables any function to call any other function (or coroutine) without any restrictions.
You are not limited to a Workflow calling a set of Activities, typically resulting is a call graph that only goes one level deep.
In Resonate, your Durable Call Graph can extend indefinitely, many levels deep, and you can call functions recursively.
In Temporal you can not call functions recursively (if you want Durability).

        <Tabs
        defaultValue="resonate"
        values={[
            {label: 'Resonate', value: 'resonate'},
            {label: 'Temporal', value: 'temporal'},
            ]}
        >
            <TabItem value="resonate">

![Resonate call levels](/img/resonate-call-levels.svg)

            </TabItem>

            <TabItem value="temporal">

![Temporal call levels](/img/temporal-call-levels.svg)

            </TabItem>

        </Tabs>

With Resonate, all functions and coroutines registered with Resonate (or called by a coroutine) have a Context object passed to it as the first argument.
This Context object has API methods which you use to Durably invoke other functions, sleep, create Durable Promises, and more.

Unlike Temporal, Resonate does not support registering Class methods.
Resonate promotes a procedural programming model that aims to enable developers to reason about their code more easily.
Using Class methods opens up a whole set of problems around state management that Resonate seeks to avoid.
In Temporal, you can use a Class to share dependencies among Activities.
In Resonate, you can achieve the same thing by registering dependencies using a Context object.

        <Tabs
        defaultValue="resonate"
        values={[
            {label: 'Resonate', value: 'resonate'},
            {label: 'Temporal', value: 'temporal'},
        ]}
        >
            <TabItem value="resonate">

```python
from resonate import Resonate

resonate = Resonate()

resonate.set_dependency("database_connection", DatabaseConnection())

@resonate.register
def insert_to_database(ctx, data):
    db_connection = ctx.get_dependency("database_connection")
    db_connection.insert(data)
    return "Data inserted!"
```

            </TabItem>

            <TabItem value="temporal">

```python
from temporalio import activity

class Activities:
    def __init__(self, database_connection):
        self.database_connection = database_connection

    @activity.defn
    async def insert_to_database(self, data):
        self.database_connection.insert(data)
        return "Data inserted!"
```

            </TabItem>

        </Tabs>



        </TabItem>

        <TabItem value="typescript">

Comparison of TypeScript SDKs between Resonate and Temporal.

        <Tabs
        groupId="coming-from-temporal"
        defaultValue="resonate"
        values={[
            {label: 'Resonate', value: 'resonate'},
            {label: 'Temporal', value: 'temporal'},
        ]}
        >

            <TabItem value="resonate">

:::caution

A new release of the TypeScript SDK is currently in development.

:::

            </TabItem>

            <TabItem value="temporal">

            </TabItem>

        </Tabs>

    </TabItem>

</Tabs>

## Load balancing

In Temporal, your Workflows and Activities execute on Workers.
You run as many Workers as you need to handle the load of your application.
Temporal automatically gives tasks to the Workers that are available to handle them.
To have specific Workers handle specific Workflows or Activities, you use Task Queues.
When you run a Worker, you tell it which Task Queue to listen to.
Sticky Queues are built in to enhance performance.

In this respect, Resonate is very similar.
Your functions execute inside Worker processes (sometimes we call them Application Nodes).
You run as many Workers as you need to handle the load of your application.
Resonate automatically sends messages (tasks) to the Workers that are available to handle them.
When you run a Worker you tell it which group to join.
However, Resonate also lets you specify specific IDs for Workers.
Which gives you, the developer, full control over unicast, anycast, or anycast with preference routing.

Resonate routing schema:

```
<transport_plugin>://<uni | any>/<group>/<id>
```

:::differentiator Transport plugin

Noticing that a transport_plugin is part of the routing schema?

This is because Resonate supports multiple transports, not just long polling.

Jump to the [Durable Async RPC section](#durable-async-rpc) to learn more.

:::

<Tabs
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>
    <TabItem value="python">

Comparison of Python SDKs between Resonate and Temporal.

        <Tabs
        defaultValue="resonate"
        values={[
            {label: 'Resonate', value: 'resonate'},
            {label: 'Temporal', value: 'temporal'},
        ]}
        >
            <TabItem value="resonate">

**Worker process example**

```python
# worker_a.py
from resonate import Resonate

resonate = Resonate.remote(
    group="worker_group_a",
    id="worker_a_1"  # Optional, unique ID for this Worker
)

@resonate.register
def foo(ctx, params):
    # ...
    return result:

resonate.start()
```

**Routing invocation example**

```python
# invoke.py
from resonate import Resonate

resonate = Resonate.remote(
    group="invoke",
)

# anycast
handle = resonate.options(target="poll://any@worker_group_a").begin_rpc("promise-id", "foo", params)

# anycast with preference
handle = resonate.options(target="poll://any@worker_group_a/worker_a_1").begin_rpc("promise_id", "foo", params)

# unicast
handle = resonate.options(target="poll://uni@worker_group_a/worker_a_1").begin_rpc("promise_id", "foo", params)
```

            </TabItem>

            <TabItem value="temporal">

**Worker process example**

```python
# worker_a.py
from temporalio.client import Client
from temporalio.worker import Worker
from temporalio import workflow

@workflow.defn
async def foo(ctx, params):
    #...
    return result

async def main():
    client = await Client.connect()
    worker = Worker(
        client,
        task_queue="worker_group_a",
        workflows=[foo],
    )
    await worker.run()
```

**Routing invocation example**

```python
# invoke.py
from temporalio.client import Client

client = await Client.connect()

# anycast, prefence is established by the Temporal System
# Or, you only have 1 worker connected to the Task Queue
result = await client.execute_workflow(
    "foo",
    params,
    id="workflow-id",
    task_queue="your-task-queue",
)
```

            </TabItem>

        </Tabs>

    </TabItem>

    <TabItem value="typescript">

    </TabItem>

</Tabs>

## Data in / data out

In Temporal, you can use Signals and Queries to send data into a Workflow and get data out of a Workflow respectively.
This enables a sort of Actor model where the Workflow Execution can act as a stateful entity that can receive and respond to messages.
However, the main problem with Temporal Signals specifically, is that there is no way to guarantee ordering.
And, you have to handle the eventual issue of large Event Histories.

Resonate does not promote the use of the Actor model.
As said previously, Resonate promotes a procedural programming model.
And therefore, Resonate does not have Signals and Queries.

However, when it comes to getting data into a running function, you can achieve similar functionality, with rock-solid ordering guarantees, using Durable Promises.
In Resonate you create a Durable Promise that is not attached to any function execution.
Then, you can resolve it from anywhere, sending data into the function while doing so.

<Tabs
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}
>

    <TabItem value="python">

    </TabItem>

    <TabItem value="typescript">

    </TabItem>

</Tabs>

## System architecture

Temporal forces a star-like topology where all Workers in an application connect to a single Temporal Server.
You must size your Temporal Service ahead of time to handle the load of all Workers in your application.
If you size it incorrectly, you have to migrate to a new setup, which is a complex process.
And though you can now make cross-Namespace calls in Temporal using Nexus, getting that set up is not trivial.

Resonate, on the other hand, is designed to for an application to use multiple Resonate Servers that can communicate with each other.

<Tabs
    defaultValue="resonate"
    values={[
        {label: 'Resonate', value: 'resonate'},
        {label: 'Temporal', value: 'temporal'},
    ]}
>

    <TabItem value="resonate">

![Resonate architecture](/img/resonate-system-arch.svg)

    </TabItem>

    <TabItem value="temporal">

![Temporal architecture](/img/temporal-system-arch.svg)

    </TabItem>

</Tabs>
