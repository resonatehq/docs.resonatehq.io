---
id: index
title: Develop with Resonate
description: Develop your application with a Resonate SDK.
sidebar_label: Develop
last_update:
  date: "08-25-2025"
tags:
  - develop
---

The Resonate API surface area is designed to fit the needs of a distributed application developer.

The API is intentionally minimal.
With just a small set of primitives, you can do most of the heavy lifting required for building distributed applications.
This surface area was designed carefully: it’s simple to learn, yet powerful enough to address the core challenges developers face when writing resilient, distributed systems.

Every API call in Resonate is durable by default.
That means your operations survive process crashes, restarts, and unexpected failures.
You don’t have to wire up custom retry loops or invent your own fault tolerance patterns — Resonate takes care of this, letting you focus on your business logic instead of infrastructure plumbing.

Distributed applications introduce unique problems: coordination across processes, ordering of events, fault handling, and more.
Developers often patch these problems with ad-hoc solutions that make the business process hard to follow and even harder for new contributors to understand.
Resonate smooths away this complexity by giving you APIs that make sense at the business-logic level, while still solving for the hard distributed systems problems underneath.

These docs aim to meet you where you are — whether you’re new to distributed programming or already familiar with the common pain points — while guiding you into the “Resonate way” of thinking about system design.
Each code sample shown here is deliberately minimal, to highlight exactly what the API looks like and where it fits in the broader ecosystem of distributed application development.
From there, you’ll find links to more detailed examples with step-by-step explanations.

## Installing SDKs

Resonate SDKs can be installed using your favorite package manager.

Quick example:

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```shell
uv add resonate-sdk
```

[More examples of installing the Resonate Python SDK](/develop/python#installation).

    </TabItem>
    <TabItem value="typescript">

```shell
bun add @resonatehq/sdk
```

[More examples of installing the Resonate TypeScript SDK](/develop/typescript#installation).

    </TabItem>

</Tabs>

## Initializing clients

You need to initialize a Resonate Client in each process that you want to use Resonate.

A Resonate Client connects to a Resonate Server and message sources while providing the top level APIs needed to durably invoke function executions.

It is important to note that your Resonate Client does not need to connect to a Resonate Server to start developing.
You can use the Resonate Client in "local mode", working with functions that are local to the process.

This is in contrast to Temporal, Restate, and DBOS which require connecting to a server or database, even for development.

Resonate calls this capability "Zero dependency development".

Quick example:

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
from resonate import Resonate

# Initialize a Resonate Client in local mode
resonate = Resonate.local()
```

[More examples of initializing a Resonate Client in Python](/develop/python#initialization).

    </TabItem>

    <TabItem value="typescript">

```ts
import { Resonate } from "@resonatehq/sdk";

// Initialize a Resonate Client in local mode
const resonate = Resonate.local();
```

[More examples of initializing a Resonate Client in TypeScript](/develop/typescript#initialization).

    </TabItem>

</Tabs>

## Client APIs

Many Resonate Client APIs can be used just about anywhere.
Seriously.
For example, the Resonate TypeScript SDK can run in your browser, enabling Async RPCs from your frontend code, or converting your browser session into a worker.

### Registering functions

Registering a function is a lot like exposing a service endpoint.

Resonate promotes a concept called the [Call Graph](https://journal.resonatehq.io/p/resonate-call-graphs).
Effectively, it is a graph of function calls that can span multiple processes.
The first function in the Call Graph is called the "top level" function.

The "top level" function must be registered with Resonate.
A registered function becomes a Durable Function.
A registered function can be invoked from any other process with a Resonate Client connected to the same Resonate Server.

The first argument of a registered function will always be a Resonate Context, which can be used to call other functions.
Local functions do not need to be registered, but will become Durable Functions if invoked from the registered Durable Function.

Note that all parameters passed to a Durable Functions must be serializable.

Quick example:

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

In Python, you can use the `@resonate.register` decorator to register a function:

```py
@resonate.register
def foo(context: Context, arg: str) -> str:
    # ...
    return result
```

[More examples of the Resonate Register API in Python](/develop/python#resonateregister).

    </TabItem>

    <TabItem value="typescript">

In TypeScript, you can use the `register` method to register a function:

```ts
fooR = resonate.register("foo", (context: Context, arg: string): string => {
  // ...
  return result;
});
```

[More examples of the Resonate Register API in TypeScript](/develop/typescript#register).

    </TabItem>

</Tabs>

### Dependency injection

Let's say that you have initialized a DB connection or some other resource that some of your functions in that process might need to use.
You can set a dependency with the Resonate Client which makes it available to all Durable Functions in that process.

Quick example:

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python" >

```python
resonate.set_dependency("db", db_connection)
```

[More examples of the Resonate Set Dependency API in Python](/develop/python#set_dependency).

</TabItem>

    <TabItem value="typescript">

```ts
resonate.setDependency("db", db_connection);
```

[More examples of the Resonate Set Dependency API in TypeScript](/develop/typescript#setdependency).

    </TabItem>

</Tabs>

### Promises

Promises are the key primitive for asynchronous programming in Resonate.
They allow you to represent a value that may not be available yet, but will be at some point in the future.
As a developer, you effectively are programming with async/await across processes.
Resonate promises are durable, however, persisted by the Resonate Server.

The Resonate Client enables you to create, get, resolve, and reject promises.

These APIs are make it possible to manage the lifecycle of a promise outside of the Call Graph.

The Create Promise API is useful for creating a promise before invoking the function that will resolve it later.
And a common reason for using the Get Promise API, is to check whether a promise exists, and if it does, whether it is resolved.
For example, if you have a long-running background job that you want to check on, you can use the get promise API to get the handle of the promise and check if it is resolved yet.

Quick examples:

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```python
# create a promise
resonate.promises.create(
    id="promise-id",
    timeout=int(time.time() * 1000) + 30000,  # 30s in the future
)

# get a promise
resonate.promises.get("promise-id")

# resolve a promise
resonate.promises.resolve("promise-id")

# reject a promise
resonate.promises.reject("promise-id")

```

[More examples of the Resonate Promise APIs in Python](/develop/python#promisescreate).

    </TabItem>

    <TabItem value="typescript">

```ts
// create a promise
const p = await resonate.promises.create(
  "promise-id",
  Date.now() + 30000 // timeout set for 30 seconds in the future
);

// get a promise
const p = await resonate.promises.get("promise-id");

// resolve a promise
await resonate.promises.resolve("promise-id");

// reject a promise
await resonate.promises.reject("promise-id");
```

[More examples of the Resonate Promise APIs in TypeScript](/develop/typescript#promisescreate).

    </TabItem>

</Tabs>

### Run

Run is the workhorse API for your local process.

The Run API on the Resonate Client is for invoking functions locally (in the same process).
Basically, its the equivalent of a normal function call, but it creates a checkpoint so even if your process crashes, the caller function can resume in a new process.

The Run API is synchronous, meaning it will block until the callee function completes and returns a result.
So there is also a Begin Run API, which is asynchronous and does not block.

Basically Run returns the value of the function being called while Begin Run returns a promise/handle to the function being called, which can be used to get the result later.

Quick example:

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
# process x
# foo() and main() are in the same process
@resonate.register
def foo(ctx: Context, arg: str) -> str:
    # ...
    return

def main():
    # synchronous call with Run API
    result = foo.run("invocation-id", "Hello World!")

    # asynchronous call with Begin Run API
    handle = foo.begin_run("invocation-id", "Hello World!")
    # ...
    result = handle.result()
```

[More examples of the Resonate Run API in Python](/develop/python#run).

    </TabItem>

    <TabItem value="typescript">

```ts
// process x
// foo() and main() are in the same process
const fooR = resonate.register("foo", (ctx: Context, arg: string): string => {
  // ...
  return result;
});

async function main() {
  // synchronous call with Run API
  const result = await fooR.run("invocation-id", "Hello World!");

  // asynchronouse call with Begin Run API
  const handle = await fooR.beginRun("invocation-id", "Hello World!");
  // ...
  const result = await handle.result;
}
```

[More examples of the Resonate Run API in TypeScript](/develop/typescript#run-1)

    </TabItem>

</Tabs>

### RPC

The RPC API on the Resonate Client enables you to invoke a Durable Function in a different process and synchronously wait for the result.

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
# process x
@resonate.register
def foo(context: Context, arg: str):
    # ...
    return result


# process y
def main():
    result = resonate.options(target="process-x").rpc(
        "invocation_id", func="foo", arg="Hello World!"
    )
```

[More examples of the Resonate RPC API in Python](/develop/python#rpc-1).

    </TabItem>

    <TabItem value="typescript">

```ts
// process x
resonate.register("foo", (ctx: Context, arg: string) => {
  // ...
  return result;
});

// process y
async function foo() {
  try {
    const arg = "hello world!";
    const result = await resonate.rpc(
      "write_once_id",
      "foo",
      arg,
      resonate.options({
        target: "process-group-b",
      })
    );
  } catch (error) {
    // ...
  }
}
```

[More examples of the Resonate RPC API in TypeScript](/develop/typescript#rpc-1)

    </TabItem>

</Tabs>

### Begin RPC

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
# process x
@resonate.register
def foo(context: Context, arg: str):
    # ...
    return result


# process y
def main():
    handle = resonate.options(target="process-x").begin_rpc(
        "invocation_id", func="foo", arg="Hello World!"
    )
    result = handle.result()
```

[More examples of the Resonate Begin RPC API in Python](/develop/python#begin_rpc-1).

    </TabItem>

    <TabItem value="typescript">

```ts
// process x
resonate.register("foo", (ctx: Context, arg: string) => {
  // ...
  return result;
});

// process y
async function foo() {
  try {
    const arg = "hello world!";
    const handle = await resonate.beginRpc(
      "write_once_id",
      "foo",
      arg,
      resonate.options({
        target: "process-x",
      })
    );
    result = await handle.result;
  } catch (error) {
    // ...
  }
}
```

[More examples of the Resonate Begin RPC API in TypeScript](/develop/typescript#beginrpc-1).

    </TabItem>

</Tabs>

## Function APIs

These are durable to durable APIs that are used inside the "durable world" — a world that automatically resumes after recovery.

### Get dependency

Get a dependency that was set on the Resonate Client in the same process.

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
db_conn = ctx.get_dependency("database-connection")
```

[More examples of the Resonate Get Dependency API in Python](/develop/python#get_dependency).

    </TabItem>

    <TabItem value="typescript">

```ts
const db_conn = ctx.getDependency("database-connection");
```

[More examples of the Resonate Get Dependency API in TypeScript](/develop/typescript#getdependency).

    </TabItem>

</Tabs>

### Get or create promise

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
promise = yield ctx.promise(id="promise-id")
```

[More examples of the Resonate Get or Create Promise API in Python](/develop/python#promise).

    </TabItem>

    <TabItem value="typescript">

```ts
const promise = yield* ctx.promise({ id: "promise-id" });
});
```

[More examples of the Resonate Get or Create Promise API in TypeScript](/develop/typescript#promise).

    </TabItem>

</Tabs>

### Sleep

Put the function to sleep for a specified duration without blocking the process.

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py
yield ctx.sleep(5.0) // sleep for 5 seconds
```

[More examples of the Resonate Sleep API in Python](/develop/python#sleep).

    </TabItem>

    <TabItem value="typescript">

```ts
yield* ctx.sleep(5000); // sleep for 5 seconds
}
```

[More examples of the Resonate Sleep API in TypeScript](/develop/typescript#sleep).

    </TabItem>

</Tabs>

### Generate random number

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py

```

    </TabItem>

    <TabItem value="typescript">

```ts

```

    </TabItem>

</Tabs>

### Get the time

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py

```

    </TabItem>

    <TabItem value="typescript">

```ts

```

    </TabItem>

</Tabs>

### Run

The Context Run API invokes a function in the **same process** in a **synchronous manner**.

When to use this API?

Use the Context Run API when you want to checkpoint the next step in your application / workflow.
This checkpoint makes it possible to replay the calling function with the result of the callee.
Use this API if you want the calling function to wait for the result before continuing.

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```python
@resonate.register
def foo(ctx: Context, arg: string):
    # ...
    result = yield ctx.run(bar, arg)
    # do more stuff
    # ...


def bar(ctx: Context, arg: string):
    # ...
    return result
```

[More examples of the Resonate Run API in Python](/develop/python#run-1).

    </TabItem>

    <TabItem value="typescript">

````ts
resonate.register("foo", function* (ctx: Context, ...args: any[]) {
  // ...
  const result = yield* ctx.run(bar, ...args);
  // do more stuff
  // ...
});

function bar(ctx: Context, ...args: any[]) {
  // ...
  return;
}

    </TabItem>

</Tabs>

### Begin run

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py

````

    </TabItem>

    <TabItem value="typescript">

```ts

```

    </TabItem>

</Tabs>

### RPC

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py

```

    </TabItem>

    <TabItem value="typescript">

```ts

```

    </TabItem>

</Tabs>

### Begin RPC

<Tabs
    groupId="preferred-language"
    defaultValue="python"
    values={[
        {label: 'Python', value: 'python'},
        {label: 'TypeScript', value: 'typescript'},
    ]}>

    <TabItem value="python">

```py

```

    </TabItem>

    <TabItem value="typescript">

```ts

```

    </TabItem>

</Tabs>
