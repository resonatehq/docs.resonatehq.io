---
id: typescript
title: TypeScript SDK API guidance
description: Use Resonate's TypeScript SDK in your next project.
sidebar_label: TypeScript SDK
last_update:
  date: "08-18-2025"
toc_max_header_level: 4
pagination_next: null
pagination_prev: null
tags:
  - typescript
  - sdk-guidance
---

Welcome to the Resonate Typescript SDK guide!
This SDK makes it possible to write Distributed Async Await applications with Typescript.
This guide covers installation and features that the SDK offers.

:::tip API reference

Looking for the API reference?

The Resonate TypeScript SDK API reference is available [here](https://resonatehq.github.io/resonate-sdk-ts/).

:::

## Installation

**How to install the Resonate Typescript SDK into your project.**

To install the Resonate Typescript SDK, you can use any of your favorite package managers.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs
    groupId="preferred-package-manager-ts"
    defaultValue="bun"
    values={[
        {label: 'Bun', value: 'bun'},
        {label: 'npm', value: 'npm'},
        {label: 'Yarn', value: 'yarn'},
    ]}>

    <TabItem value="bun">

```shell
bun add @resonatehq/sdk
```

    </TabItem>

    <TabItem value="npm">

```shell
npm install @resonatehq/sdk
```

    </TabItem>

    <TabItem value="yarn">

```shell
yarn add @resonatehq/sdk
```

    </TabItem>

</Tabs>

## Initialization

**How to initialize a Resonate Client.**

You will need to initialize a Resonate Client in each process that you want to use Resonate in.

There are two ways to initialize Resonate, local and remote.

**Local initialization**

Local initialization means that Resonate uses local memory for promise storage.
This is ideal for getting started quickly or for integrating Resonate into an existing application without relying on dependencies.
However, just remember that you can't use Resonate's Async RPC or recover executions from process / worker crashes in local mode.

```typescript
import { Resonate } from "@resonate/sdk";

const resonate = Resonate.local();
```

**Remote initialization**

Remote initialization means that promises are stored remotely, and that the worker receives messages from a remote source.
This is how Resonate enables Async RPC for building distributed applications that are reliable and scalable.

When you initialize Resonate in remote mode, you need to specify the group that the process is a part of.
By default, the client will try to connect to a local Resonate Server running on `http://localhost:8001`.

```typescript
import { Resonate } from "@resonate/sdk";

const resonate = Resonate.remote({
  group: "<group-name>",
});

// If you need to specify a different Resonate Server
const resonate = Resonate.remote({
  host: "https://my-resonate.com",
  group: "<group-name>",
});
```

{/* Resonate workers can receive messages from many different transports, such as HTTP, RabbitMQ, RedPanda, etc... */}

{/* The Poller is a great starting place as it will long-poll for messages from the Resonate Server without any additional setup. */}

## Client APIs

Resonate client APIs are used in the "ephemeral world".

:::tip Ephemeral vs Durable

In the context of Resonate, we use the term "ephemeral" for functions that do not automatically recover and resume after a process crash.
Whereas, the term "durable" is used for functions that do.

You can think of Ephmeral-to-Durable APIs as Resonate Client APIs.
That is — these are the APIs that are used at the edge of your Resonate application.

:::

### `.register()`

**How to register a function with Resonate in the Typescript SDK.**

After you have initialized Resonate, you can register functions with it.

If Resonate is initialized in local mode, the registered functions are only available to be called from that process.
However, if Resonate is initialized in remote mode, then the registered functions become available to any process that is connected to the same Resonate Server.

Using the `.register()` method is the only way to register a function with the TypeScript SDK.

**Method**

```typescript
function foo(ctx: Context, ...args: any): any {
  // ...
  return result;
}

resonate.register("foo", foo);

// OR

const rFoo = resonate.register("foo", foo);
```

### `.setDependency()`

**How to inject a dependency into Resonate function call stack**

Use the `.setDependency()` method to set dependencies for your functions. If you have a database connection, a client object, custom logger, or other dependency that you want your functions to have access to, you can use this method to make it available.

```typescript
const foo = (ctx: Context, name: string): string => {
  const greeting = ctx.getDependency("greeting") as string;
  return `${greeting} ${name}`;
};

const rFoo = resonate.register("foo", foo);

resonate.setDependency("greeting", "Hello");
const v = await rFoo.run("rfoo", "World!");
// v === "Heloo World!"
```

**How to invoke a function in the ephemeral world with the Resonate Class.**

To move from the ephemeral world to the durable world you use the Resonate Class to invoke functions.

There are two methods that you can use `.run()` and `.rpc()`.

### `.run()`

**How to invoke a function locally (same process), synchronously (blocking), from the ephemeral world (doesn't resume after recovery).**

You can think of this as a, "I will wait while you run right here" invocation.

After invocation, the called function is durable and will recover in another process if needed.

```typescript
function foo(ctx: Context, ...args: any): any {
  // ...
  return result;
}

const fooR = resonate.register("foo", foo);

// The first argument of run is the promise id followed by the arguments to the function
const result = await fooR.run("foo");

// OR

resonate.register("foo", foo);

// For this version of run, the first argument still the promise id, this time
// followed by the function to be run and its arguemnts
const result = await resonate.run("foo", foo);
```

### `.beginRun()`

Invoke a function locally (same process), asynchronously (non-blocking), from the ephemeral world (doesn't resume after recovery) to the durable world (resumes after recovery).

```typescript
function foo(ctx: Context, ...args: any): any {
  // ...
  return result;
}

const fooR = resonate.register("foo", foo);

// The first argument of run is the promise id followed by the arguments to the function
const promiseOfResult = await fooR.run("foo");
const result = await promiseOfResult.result();

// OR

resonate.register("foo", foo);

// For this version of run, the first argument still the promise id, this time
// followed by the function to be run and its arguemnts
const promiseOfResult = await resonate.run("foo", foo);
const result = await promiseOfResult.result();
```

### `.rpc()`

Resonate's `.rpc()` method (Remote Procedure Call) invokes the function in a remote process.

:::tip Remote initialization required

The RPC method requires that the Worker / Application Node is connected with a Resonate Server.
It also assumes that the Worker / Application Node where the invoked function is running is also connected to a Resonate Server and can receive messages.

:::

You can think of this API as a "run somewhere else" invocation (Asynchronous Remote Procedure Call).
However, if the function is registered locally, it is still possible for the function to execute in the same process.
After invocation, the function is considered durable and can recover in another process if desired.

The invocation returns a promise which can be awaited on at any point after.

**process a**

```typescript
// process a
const resonate = Resonate.remote({ group: "group-a" });

function foo(ctx: Context, ...args: any): any {
  // ...
  return result;
}

resonate.register("foo", foo);
```

**process b**

```typescript
// process b
const resonate = Resonate.remote({ group: "group-b" });

// invoke function foo from process b on process a
resonate.rpc(
  "invocation-id",
  "foo",
  args,
  resonate.options({ target: "poll://any@group-a" })
);
```

### `.beginRPC()`

### `.promises.create()`

```typescript
const promise = resonate.promises.create("my-custom-id", 50000); // must provide a promise id and timeout
```

### `.promises.get()`

Resonate's `.promise.get()`

### `.promises.resolve()`

Resonate's `.promise.resolve()`

### `.promises.reject()`

Resonate's `.promise.reject()`

## Function APIs

**How to use the Resonate Context object in the Typescript SDK.**

Resonate's Context object enables you to invoke functions from inside a Durable Function.
This is how you extend the Call Graph and create a world of Durable Functions.
Inside a Durable Function you use the `yield*` or `yield` keyword to interact with the Context object, `yield*` is recommended for improved type inference.

### `.run()`

Context's `.run()` method invokes a function in the **same process** in a **synchronous manner**.
That is — the calling function blocks until the invoked function returns.

```typescript
function* foo(ctx: Context): Generator<any, number, any> {
  // The return type of the generator is number
  const value = yield* ctx.run(bar, 2);
  return value; // 42
}

function bar(ctx: Context, n: number): number {
  return 40 + n;
}
```

### `.beginRun()`

Context's `.beginRun` method invokes a function in the **same process** in an **asynchronous manner**.
That is — the invocation returns a promise which can be awaited on at any point after.

```typescript
function* foo(ctx: Context): Generator<any, string, any> {
  const promise = yield* ctx.beginRun(bar, "Resonate");
  const value = yield* promise; // After yielding the future
  return value;
}

function bar(ctx: Context, name: string): string {
  return `Hello ${name}`;
}
```

### `.rpc()`

Context's `.rpc()` method (Remote Procedure Call) invokes a function in a **remote process** in a **synchronous manner**.
That is — the calling function blocks until the invoked function returns.

**process a**

```typescript
// process a
function* foo(ctx: Context): Generator<any, string, any> {
  const value = yield* ctx.rpc<string>(
    "bar", // This function is registered in process-b
    "process A", // arg to the function registered in process-b
    ctx.options({ target: "poll://any@group-b" })
  );
  return value; // "Called from process A"
}
resonate.register("foo", foo);
```

**process b**

```typescript
function bar(ctx: Context, from: string): string {
  return `Called from ${from}`;
}

resonate.register("bar", bar);
```

### `.beginRpc()`

Context's `.beginRpc()` method (Remote Function Invocation) invokes a function in a **remote process** in an **asynchronous manner**.
That is — the invocation returns a promise which can be awaited on at any point after.

**process a**

```typescript
// process a
function* foo(ctx: Context, ...args: any): any {
  const promise = yield* ctx.beginRpc<string>(
    "bar", // This function is registered in process-b
    "process A", // arg to the function registered in process-b
    ctx.options({ target: "poll://any@group-b" })
  );
  const value = yield* promise;
  return value; // "Called from process A"
}

resonate.register("foo", foo);
// ...
```

**process b**

```typescript
// process b
function bar(ctx: Context, from: string): any {
  return `Called from ${from}`;
}

resonate.register("bar", bar);
```

### `.getDependency()`

Context's `.getDependency()` method allows you to get a dependency that was set in the ephemeral world using the Resonate's `.setDependency()` method and use it the Durable World.

```typescript
const g = (ctx: Context, name: string): string => {
  const greeting = ctx.getDependency("greeting") as string; // Use it in the durable world
  return `${greeting} ${name}`;
};

const f = resonate.register("f", function* foo(ctx: Context) {
  const v = yield* ctx.run(g, "World!");
  return v;
});

resonate.setDependency("greeting", "Hello"); // Set it in the ephemeral world
const v = await f.run("fId"); // "Hello World!"
```

### `.sleep()`

Context's `.sleep()` method allows you to sleep inside a function.
There is no limit to how long you can sleep.
The sleep method accepts a float value in seconds.
This is a "durable" sleep, if the node crashes or suspends the "timer" for this sleep will keep going.

```typescript
const f = resonate.register("f", function* foo(ctx: Context) {
  yield* ctx.sleep(24 * util.HOUR);
  return "myValue";
});

const value = await f.run("fId"); // "myValue"
// f will take 24 hours to complete
```

### `.promise()`

Context's `.promise()` method allows you to get or create a promise that can be awaited on.

If no ID is provided, one is generated and a new promise is created.
If an ID is provided and a promise already exists with that ID, then the existing promise is returned.

This is very useful for HITL (Human-In-The-Loop) use cases where you want to block progress until a human has taken an action or provided data.
It works well in conjunction with [Resonate's `.promise.resolve()` method](#promisesresolve).

```typescript
const f = resonate.register("f", function* foo(ctx: Context) {
  const promise = yield* ctx.promise({ id: "myId" });
  return yield* promise;
});

const p = await f.beginRun("f");

await resonate.promises.resolve("myId", "myId", false, "myValue"); // Manually resolves the promise with id "myId" and value "myValue"
const value = await p.result(); // myValue
```

### `.options()`

Many of Context's methods support options on the call you are making. But you pass them as the final argument when doing the call

```typescript

function* foo(ctx: Context, ...args: any): any{
  const promise = yield ctx.beginRpc(bar, args, ctx.options({...}))
  const value = promise
  return value
}

resonate.run("foo", foo, args, resonate.options({...}))
```
